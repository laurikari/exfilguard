{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ExfilGuard","text":"<p>Egress proxy for data exfiltration prevention</p> <p>Control and monitor outbound HTTP/HTTPS traffic from your organization. Enforce per-client policies that determine exactly which external endpoints are reachable.</p>"},{"location":"#what-is-exfilguard","title":"What is ExfilGuard?","text":"<p>ExfilGuard is a Rust-based explicit egress proxy that acts as a gatekeeper for all outbound traffic. It solves the critical security problem of data exfiltration prevention by ensuring that internal services and applications can only send data to explicitly approved external endpoints.</p> <p>Organizations face risks from malicious insiders, compromised services attempting to exfiltrate sensitive data, accidental data leakage through misconfigured integrations, and compliance violations when data leaves uncontrolled. ExfilGuard addresses all of these by enforcing fine-grained, per-client policies at the application layer.</p> <p>ExfilGuard targets Unix-like systems only; Windows is not supported.</p>"},{"location":"#key-features","title":"Key Features","text":"Per-Client Policy Enforcement Map clients by exact IP address or CIDR ranges. Each client references ordered policies; the first matching rule wins. Fine-Grained URL Matching Policies specify allowed destinations using wildcard patterns for hostnames and paths. TLS Inspection Terminates TLS and mints leaf certificates on-the-fly for full request/response inspection including headers and body. Pass-Through Mode Tunnel CONNECT streams without decryption for services that use certificate pinning or refuse MITM. Optional Response Caching Shared HTTP response cache that follows standard cache headers; opt-in per rule via a <code>cache</code> block (requires cache storage configured globally). Private Upstream Guardrails Blocks upstream connections to private IPs by default to reduce SSRF risk; opt-in per rule with <code>allow_private_upstream = true</code>. Hot-Reload Configuration Supports SIGHUP signal to reload configuration without restarting the process. Zero downtime policy updates. Structured Logging JSON or text format logging with decision tracking. Logs each request's allow/deny decision with structured metadata. Metrics Exporter Optional Prometheus endpoint (<code>/metrics</code>) with counters/histograms per client/policy for traffic, decisions, cache, and pool health. Supports HTTPS when given a cert/key."},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#data-exfiltration-prevention","title":"Data Exfiltration Prevention","text":"<p>Block unauthorized attempts to send data to cloud storage, analytics platforms, or communication services.</p>"},{"location":"#compliance-audit","title":"Compliance &amp; Audit","text":"<p>Generate audit logs showing all external data flows. Demonstrate to regulators what data can leave your organization.</p>"},{"location":"#multi-tenant-saas","title":"Multi-Tenant SaaS","text":"<p>Control what external APIs different backend services can reach. Prevent rogue services from connecting to unauthorized platforms.</p>"},{"location":"#integration-management","title":"Integration Management","text":"<p>Control integrations with external partners. Enforce OAuth/API credentials usage policies by restricting host access.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#1-add-the-apt-repository","title":"1. Add the APT repository","text":"<pre><code># Download and install the signing key\ncurl -fsSL https://laurikari.github.io/exfilguard/apt/exfilguard.gpg | \\\n  sudo gpg --dearmor -o /etc/apt/keyrings/exfilguard.gpg\n\n# Add ExfilGuard repository\necho \"deb [signed-by=/etc/apt/keyrings/exfilguard.gpg] https://laurikari.github.io/exfilguard/apt ./\" | \\\n  sudo tee /etc/apt/sources.list.d/exfilguard.list\nsudo apt update\n</code></pre>"},{"location":"#2-install-exfilguard","title":"2. Install ExfilGuard","text":"<pre><code>sudo apt install exfilguard\n</code></pre>"},{"location":"#3-configure-and-start","title":"3. Configure and start","text":"<pre><code># Edit configuration\nsudo nano /etc/exfilguard/exfilguard.toml\n\n# Start the service\nsudo systemctl enable --now exfilguard\n</code></pre>"},{"location":"#quick-examples","title":"Quick Examples","text":""},{"location":"#allow-specific-api-endpoint","title":"Allow specific API endpoint","text":"<pre><code># Allow analytics service to reach trusted endpoint\n# HTTPS rules implicitly allow the CONNECT bump for the same host/port.\n[[policy.rule]]\naction = \"ALLOW\"\nmethods = [\"GET\", \"POST\"]\nurl_pattern = \"https://api.trusted-analytics.com/v1/exports/**\"\n</code></pre>"},{"location":"#pass-through-for-certificate-pinned-services","title":"Pass-through for certificate-pinned services","text":"<pre><code># Payment gateway with certificate pinning\n[[policy.rule]]\naction = \"ALLOW\"\nmethods = [\"CONNECT\"]\nurl_pattern = \"https://secure.payment-gateway.com/**\"\ninspect_payload = false\n</code></pre>"},{"location":"#client-mapping-by-cidr","title":"Client mapping by CIDR","text":"<pre><code># Map internal subnet to specific policies\n[[client]]\nname = \"analytics-workers\"\ncidr = \"10.42.16.0/27\"\npolicies = [\"analytics-policy\", \"default-deny\"]\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Reference - Global settings and options</li> <li>Policies Guide - Client mapping and policy rules</li> </ul>"},{"location":"configuration/","title":"Configuration Reference","text":"<p>Global settings for ExfilGuard defined in <code>exfilguard.toml</code>.</p>"},{"location":"configuration/#core-settings","title":"Core Settings","text":"<p>Required settings to run ExfilGuard.</p> Field Type Required Description <code>listen</code> String Yes Listen address and port (e.g., <code>\"127.0.0.1:3128\"</code>) <code>proxy_protocol</code> String <code>\"off\"</code> PROXY protocol mode: <code>\"off\"</code>, <code>\"optional\"</code>, or <code>\"required\"</code> <code>proxy_protocol_allowed_cidrs</code> Array None CIDR allowlist for peers allowed to send PROXY headers (required when <code>proxy_protocol</code> is <code>\"optional\"</code> or <code>\"required\"</code>) <code>ca_dir</code> Path Yes Directory containing CA certificate and private key for TLS interception <code>clients</code> Path Yes Path to clients configuration file <code>policies</code> Path Yes Path to policies configuration file <code>clients_dir</code> Path No Directory containing additional client config files (*.toml) <code>policies_dir</code> Path No Directory containing additional policy config files (*.toml) <p>Note</p> <p>Relative paths are resolved from the directory containing the main config file.</p> <p>Note</p> <p>When <code>proxy_protocol</code> is <code>\"optional\"</code> or <code>\"required\"</code>, ExfilGuard auto-detects PROXY protocol v1 or v2 headers. If the peer IP is not in <code>proxy_protocol_allowed_cidrs</code>, ExfilGuard ignores any PROXY headers and treats the connection as a plain client.</p> <p>Note</p> <p><code>proxy_protocol_allowed_cidrs</code> must be set when PROXY protocol is enabled.</p>"},{"location":"configuration/#tls-certificate-settings","title":"TLS / Certificate Settings","text":"<p>Settings for TLS interception and certificate generation.</p> Field Type Default Description <code>cert_cache_dir</code> Path None Directory to cache dynamically generated TLS certificates <code>leaf_ttl</code> u64 86400 TLS certificate leaf TTL in seconds (must be &gt; 0)"},{"location":"configuration/#ca-directory-structure","title":"CA Directory Structure","text":"<p>ExfilGuard uses a two-tier CA hierarchy. The <code>ca_dir</code> must contain:</p> <pre><code>ca_dir/\n\u251c\u2500\u2500 root.crt           # Root CA certificate\n\u251c\u2500\u2500 root.key           # Root CA private key (optional when using external CA)\n\u251c\u2500\u2500 intermediate.crt   # Intermediate CA certificate (signed by root)\n\u2514\u2500\u2500 intermediate.key   # Intermediate CA private key\n</code></pre> <ul> <li>Leaf certificates are signed by the intermediate CA</li> <li>Certificate chain sent to clients: Leaf \u2192 Intermediate \u2192 Root</li> <li>Clients only need to trust the root CA</li> <li>If using an externally signed intermediate, <code>root.key</code> may be omitted</li> </ul> <p>If <code>ca_dir</code> is empty, ExfilGuard generates all four files automatically on first startup.</p>"},{"location":"configuration/#using-your-corporate-ca","title":"Using Your Corporate CA","text":"<p>To integrate with an existing PKI so clients already trust ExfilGuard's certificates:</p> <ol> <li> <p>Let ExfilGuard generate its keys (start with empty <code>ca_dir</code>, then stop):    <pre><code># Creates root.crt, root.key, intermediate.crt, intermediate.key\nexfilguard --config exfilguard.toml\n</code></pre></p> </li> <li> <p>Create a CSR from the generated intermediate key:    <pre><code>openssl req -new -key ca_dir/intermediate.key \\\n  -out intermediate.csr \\\n  -subj \"/CN=ExfilGuard Intermediate CA\"\n</code></pre></p> </li> <li> <p>Get your corporate CA to sign the CSR (produces a new certificate):    <pre><code># Example using openssl (adjust to your CA's process)\nopenssl x509 -req -in intermediate.csr \\\n  -CA corporate-ca.crt -CAkey corporate-ca.key \\\n  -CAcreateserial -out intermediate-signed.crt \\\n  -days 365 -sha256 \\\n  -extfile &lt;(echo \"basicConstraints=CA:TRUE,pathlen:0\nkeyUsage=keyCertSign,cRLSign\")\n</code></pre></p> </li> <li> <p>Replace the certificates:    <pre><code>cp corporate-ca.crt ca_dir/root.crt\ncp intermediate-signed.crt ca_dir/intermediate.crt\n# Keep the original intermediate.key - it matches the CSR\n# root.key is no longer needed (can be removed or kept)\n</code></pre></p> </li> <li> <p>Restart ExfilGuard - clients that trust your corporate CA will now trust intercepted connections.</p> </li> </ol> <p>Note</p> <p>The private key (<code>intermediate.key</code>) stays the same. You're replacing the certificate with one signed by a different authority.</p>"},{"location":"configuration/#logging-settings","title":"Logging Settings","text":"Field Type Default Description <code>log</code> String <code>\"json\"</code> Log format: <code>\"json\"</code> or <code>\"text\"</code> <code>log_queries</code> Boolean false Whether to log each request query"},{"location":"configuration/#timeout-settings","title":"Timeout Settings","text":"<p>All timeout values are in seconds. Use <code>0</code> to disable <code>request_total_timeout</code> and <code>connect_tunnel_max_lifetime</code>.</p> Field Type Default Description <code>dns_resolve_timeout</code> u64 2 Maximum time to resolve DNS for upstream hosts <code>upstream_connect_timeout</code> u64 5 Maximum time to establish upstream TCP connections <code>tls_handshake_timeout</code> u64 10 Maximum time for TLS handshakes (client or upstream) <code>request_header_timeout</code> u64 10 Maximum time to read an HTTP request line + headers <code>request_body_idle_timeout</code> u64 30 Maximum idle time between request body reads/writes <code>response_header_timeout</code> u64 30 Maximum time to receive upstream response headers <code>response_body_idle_timeout</code> u64 60 Maximum idle time between response body reads/writes <code>request_total_timeout</code> u64 0 Maximum time from request start to upstream response headers (0 disables) <code>client_keepalive_idle_timeout</code> u64 30 Idle time before closing an idle client keep-alive connection <code>connect_tunnel_idle_timeout</code> u64 60 Maximum idle time for CONNECT tunnels <code>connect_tunnel_max_lifetime</code> u64 0 Maximum lifetime for CONNECT tunnels (0 disables)"},{"location":"configuration/#request-size-limits","title":"Request Size Limits","text":"<p>All size values are in bytes and must be greater than 0.</p> Field Type Default Description <code>max_request_header_size</code> usize 32768 (32 KiB) Maximum HTTP request header size <code>max_response_header_size</code> usize 32768 (32 KiB) Maximum HTTP response header size <code>max_request_body_size</code> usize 67108864 (64 MiB) Maximum HTTP request body size"},{"location":"configuration/#connection-pool","title":"Connection Pool","text":"Field Type Default Description <code>upstream_pool_capacity</code> usize 32 Maximum number of upstream connections to pool (must be &gt;= 1)"},{"location":"configuration/#metrics","title":"Metrics","text":"Field Type Default Description <code>metrics_listen</code> String None Optional listen address (e.g., <code>\"127.0.0.1:9090\"</code>) to serve Prometheus metrics at <code>/metrics</code> <code>metrics_tls_cert</code> Path None PEM certificate chain to enable HTTPS for <code>/metrics</code> <code>metrics_tls_key</code> Path None PEM private key matching <code>metrics_tls_cert</code> <p>Exports counters and histograms for per-client/policy decisions and latency, cache activity, and connection pool health.</p>"},{"location":"configuration/#cache-settings","title":"Cache Settings","text":"<p>Response caching is opt-in per rule. The cache settings here configure the shared cache storage.</p> Field Type Default Description <code>cache_dir</code> Path None Directory for response cache storage <code>cache_max_entry_size</code> u64 10485760 (10 MiB) Maximum size of individual cache entries <code>cache_max_entries</code> usize 10000 Maximum number of cached responses (LRU) <code>cache_total_capacity</code> u64 1073741824 (1 GiB) Total cache capacity <code>cache_sweeper_interval</code> u64 300 Interval in seconds between cache sweeper runs <code>cache_sweeper_batch_size</code> usize 1000 Maximum metadata entries inspected per sweep"},{"location":"configuration/#cache-behavior","title":"Cache Behavior","text":"<p>The cache respects standard HTTP caching semantics from upstream servers.</p>"},{"location":"configuration/#scope","title":"Scope","text":"<p>The cache is shared across all clients. Responses are keyed by method + absolute URI, with <code>Vary</code> request headers used to decide cache hits. Enable caching only if cross-client sharing is acceptable for your deployment.</p>"},{"location":"configuration/#supported-headers","title":"Supported Headers","text":"<ul> <li>Cache-Control: <code>max-age</code>, <code>s-maxage</code>, <code>public</code>, <code>private</code>, <code>no-cache</code>, <code>no-store</code></li> <li>Expires: HTTP date for cache expiration</li> <li>Vary: Cache keys include request headers specified by Vary</li> </ul>"},{"location":"configuration/#ttl-priority","title":"TTL Priority","text":"<p>Cache lifetime is determined in this order:</p> <ol> <li><code>s-maxage</code> (shared cache max-age) - highest priority</li> <li><code>max-age</code></li> <li><code>Expires</code> header</li> <li><code>force_cache_duration</code> from policy rule (fallback only)</li> </ol>"},{"location":"configuration/#what-gets-cached","title":"What Gets Cached","text":"<ul> <li>Methods: Only <code>GET</code> and <code>HEAD</code> requests</li> <li>Status codes: 200, 203, 204, 205, 206, 301, 302</li> <li>Bypass: Requests with <code>Authorization</code> or <code>Cookie</code> headers are never served from cache   and are not stored</li> <li>Not cached: Responses with <code>no-store</code>, <code>no-cache</code>, or <code>private</code> directives, or any <code>Set-Cookie</code> header</li> </ul>"},{"location":"configuration/#request-cache-directives","title":"Request Cache Directives","text":"<p>Request-side cache controls are honored for bypass. If a request includes <code>Cache-Control: no-cache</code>, <code>Cache-Control: no-store</code>, <code>Cache-Control: max-age=0</code>, or <code>Pragma: no-cache</code>, the cache will not be used and the response will not be stored. Caching decisions otherwise follow upstream response headers plus <code>force_cache_duration</code> from policy rules.</p>"},{"location":"configuration/#eviction","title":"Eviction","text":"<p>Uses LRU (Least Recently Used) eviction when capacity is reached. Expired entries are removed on lookup.</p>"},{"location":"configuration/#layout-and-sweeping","title":"Layout and Sweeping","text":"<p>Cache entries live under a versioned subdirectory (<code>v1</code> under the cache root). When the layout version changes, old version directories are deleted asynchronously. A background sweeper runs every <code>cache_sweeper_interval</code> seconds and inspects up to <code>cache_sweeper_batch_size</code> entries, removing expired entries and pruning empty shard directories.</p> <p>Note</p> <p>The cache does not support conditional revalidation (ETag/If-None-Match, Last-Modified/If-Modified-Since). Stale entries are discarded and fetched fresh from upstream.</p>"},{"location":"configuration/#environment-variables","title":"Environment Variables","text":"<p>All settings can be overridden via environment variables using the <code>EXFILGUARD__</code> prefix with double underscores for nesting.</p> <pre><code># Override listen address\nEXFILGUARD__LISTEN=\"0.0.0.0:3128\"\n\n# Override log format\nEXFILGUARD__LOG=\"text\"\n\n# Override timeouts\nEXFILGUARD__CLIENT_KEEPALIVE_IDLE_TIMEOUT=60\nEXFILGUARD__UPSTREAM_CONNECT_TIMEOUT=120\n</code></pre>"},{"location":"configuration/#complete-example","title":"Complete Example","text":"<pre><code># Core settings\nlisten = \"127.0.0.1:3128\"\nca_dir = \"./ca\"\ncert_cache_dir = \"./cert_cache\"\nclients = \"clients.toml\"\npolicies = \"policies.toml\"\nclients_dir = \"clients.d\"\npolicies_dir = \"policies.d\"\n\n# Logging\nlog = \"text\"\nlog_queries = false\n\n# TLS\nleaf_ttl = 86400\n\n# Timeouts (seconds)\ndns_resolve_timeout = 2\nupstream_connect_timeout = 5\ntls_handshake_timeout = 10\nrequest_header_timeout = 10\nrequest_body_idle_timeout = 30\nresponse_header_timeout = 30\nresponse_body_idle_timeout = 60\nrequest_total_timeout = 0\nclient_keepalive_idle_timeout = 30\nconnect_tunnel_idle_timeout = 60\nconnect_tunnel_max_lifetime = 0\n\n# Connection pool\nupstream_pool_capacity = 32\n\n# Size limits (bytes)\nmax_request_header_size = 32768\nmax_response_header_size = 32768\nmax_request_body_size = 67108864\n\n# Cache (optional)\ncache_dir = \"./cache\"\ncache_max_entry_size = 10485760\ncache_max_entries = 10000\ncache_total_capacity = 1073741824\ncache_sweeper_interval = 300\ncache_sweeper_batch_size = 1000\n</code></pre>"},{"location":"http-framing/","title":"HTTP/1.1 Request Framing","text":"<p>ExfilGuard parses HTTP/1.1 request bodies according to RFC 9112: HTTP/1.0 requests are not supported.</p> <ul> <li>If <code>Transfer-Encoding</code> is present, it defines the body framing.</li> <li>Else if <code>Content-Length</code> is present, it defines the body length.</li> <li>Else the body length is <code>0</code> for HTTP/1.1 keep-alive connections.</li> </ul> <p>This means a request without <code>Content-Length</code> or <code>Transfer-Encoding</code> is treated as having no body, and any bytes after the header terminator are parsed as the next request on the same connection. ExfilGuard does not read until EOF because EOF is only a valid delimiter when the connection is being closed.</p>"},{"location":"http-framing/#legacy-or-lenient-upstreams","title":"Legacy or Lenient Upstreams","text":"<p>Some legacy servers treat a missing length as \"read until close\". With keep-alive connections this can lead to timeouts or unexpected behavior. If you must communicate with such servers, ensure clients send a <code>Content-Length</code> or <code>Transfer-Encoding</code>, or have the client send <code>Connection: close</code> so EOF becomes an explicit delimiter.</p>"},{"location":"policies/","title":"Clients &amp; Policies","text":"<p>Define who can access what with client mappings and policy rules.</p>"},{"location":"policies/#client-configuration","title":"Client Configuration","text":"<p>Clients map source IP addresses to policies. Defined in <code>clients.toml</code> or files in <code>clients.d/</code>.</p>"},{"location":"policies/#client-fields","title":"Client Fields","text":"Field Type Required Description <code>name</code> String Yes Unique identifier for the client <code>ip</code> String One of ip/cidr Single IP address (e.g., <code>\"127.0.0.1\"</code>, <code>\"::1\"</code>) <code>cidr</code> String One of ip/cidr CIDR block (e.g., <code>\"10.0.0.0/8\"</code>, <code>\"2001:db8::/32\"</code>) <code>policies</code> Array Yes List of policy names to apply in order <code>fallback</code> Boolean No Mark as fallback client (exactly one required)"},{"location":"policies/#matching","title":"Matching","text":"<p>Client selectors must not overlap, so each source IP maps to at most one non-fallback client. If no selector matches, the fallback client is used.</p>"},{"location":"policies/#validation-rules","title":"Validation Rules","text":"<ul> <li>Client names must be unique</li> <li>Either <code>ip</code> or <code>cidr</code> must be specified, not both</li> <li>Non-fallback selectors must not overlap (IP vs IP, IP vs CIDR, CIDR vs CIDR)</li> <li>Exactly one client must have <code>fallback = true</code></li> <li>All referenced policies must exist</li> </ul>"},{"location":"policies/#example","title":"Example","text":"<pre><code># Analytics workers subnet\n[[client]]\nname = \"analytics-workers\"\ncidr = \"10.42.16.0/27\"\npolicies = [\"analytics-policy\", \"fallback-deny\"]\n\n# Payment gateway subnet\n[[client]]\nname = \"payments-gateway\"\ncidr = \"10.42.48.0/28\"\npolicies = [\"payments-policy\", \"fallback-deny\"]\n\n# Localhost for testing\n[[client]]\nname = \"loopback\"\nip = \"127.0.0.1\"\npolicies = [\"local-allow\"]\n\n# Fallback: deny everything else\n[[client]]\nname = \"fallback\"\ncidr = \"0.0.0.0/0\"\npolicies = [\"default-deny\"]\nfallback = true\n</code></pre>"},{"location":"policies/#policy-configuration","title":"Policy Configuration","text":"<p>Policies contain ordered rules that determine whether requests are allowed or denied. Defined in <code>policies.toml</code> or files in <code>policies.d/</code>.</p>"},{"location":"policies/#policy-structure","title":"Policy Structure","text":"<pre><code>[[policy]]\nname = \"policy-name\"\n  [[policy.rule]]\n  # rule fields...\n</code></pre> <p>Rules are evaluated in order. The first matching rule determines the action.</p>"},{"location":"policies/#rule-fields","title":"Rule Fields","text":"Field Type Default Description <code>action</code> String Required <code>\"ALLOW\"</code> or <code>\"DENY\"</code> <code>methods</code> Array <code>[\"ANY\"]</code> HTTP methods to match (non-CONNECT by default) <code>url_pattern</code> String None URL pattern to match (see syntax below) <code>inspect_payload</code> Boolean true Whether to inspect request/response bodies <code>allow_private_upstream</code> Boolean false Allow upstream requests to private IPs (ALLOW only) <code>cache</code> Table None Cache configuration (see below) <code>status</code> u16 Required for DENY HTTP status code for denial response <code>reason</code> String None HTTP reason phrase (DENY only) <code>body</code> String None Response body (DENY only)"},{"location":"policies/#allow-vs-deny","title":"ALLOW vs DENY","text":""},{"location":"policies/#allow-rules","title":"ALLOW Rules","text":"<ul> <li>Permit the request to proceed upstream</li> <li>Must not set <code>status</code>, <code>reason</code>, or <code>body</code></li> <li>Can use <code>inspect_payload = false</code> for tunnel mode</li> <li>Can set <code>allow_private_upstream = true</code></li> </ul>"},{"location":"policies/#deny-rules","title":"DENY Rules","text":"<ul> <li>Block the request with specified response</li> <li>Must set <code>status</code> (HTTP status code)</li> <li>Optional: <code>reason</code> and <code>body</code></li> <li>Cannot use <code>allow_private_upstream</code></li> </ul>"},{"location":"policies/#http-methods","title":"HTTP Methods","text":"<p>Valid method values:</p> <ul> <li><code>\"ANY\"</code> - Matches all non-CONNECT methods (default)</li> <li><code>\"GET\"</code>, <code>\"POST\"</code>, <code>\"PUT\"</code>, <code>\"PATCH\"</code>, <code>\"DELETE\"</code></li> <li><code>\"HEAD\"</code>, <code>\"OPTIONS\"</code>, <code>\"TRACE\"</code>, <code>\"CONNECT\"</code></li> </ul> <pre><code># Single method\nmethods = [\"GET\"]\n\n# Multiple methods\nmethods = [\"GET\", \"POST\", \"DELETE\"]\n\n# Any method (default)\nmethods = [\"ANY\"]\n</code></pre> <p>Note</p> <p>Cannot mix <code>\"ANY\"</code> with explicit methods in the same array. <code>\"CONNECT\"</code> must be the only method in its rule.</p> <p>CONNECT requests are evaluated against explicit CONNECT rules first. If no explicit CONNECT rule matches, HTTPS rules can implicitly allow a bumped tunnel, and DENY rules with <code>methods = [\"ANY\"]</code> can supply custom CONNECT denial responses.</p>"},{"location":"policies/#url-pattern-syntax","title":"URL Pattern Syntax","text":"<p>URL patterns follow the format: <code>scheme://host[:port][/path]</code></p>"},{"location":"policies/#scheme","title":"Scheme","text":"<p><code>http</code> or <code>https</code> (required)</p>"},{"location":"policies/#host-matching","title":"Host Matching","text":"Pattern Matches <code>example.com</code> Exact domain <code>*.example.com</code> Exactly one subdomain label of example.com <code>**.example.com</code> Any depth of subdomains of example.com (one or more) <code>example.**</code> Any suffix depth under example <code>*</code> Any host <code>192.0.2.1</code> Exact IPv4 address <code>[2001:db8::1]</code> Exact IPv6 address (bracketed) <p>Note</p> <p>Host matching is case-insensitive. Wildcards can only appear as entire labels: <code>*.example.com</code> and <code>**.example.com</code> are valid, <code>a*b.com</code> is not. <code>*</code> matches a single label and <code>**</code> matches one or more labels.</p>"},{"location":"policies/#port","title":"Port","text":"<p>Optional. Defaults to 80 for HTTP, 443 for HTTPS.</p> <pre><code>url_pattern = \"https://example.com:8443/api/**\"\n</code></pre>"},{"location":"policies/#path-matching","title":"Path Matching","text":"Pattern Matches <code>/api/v1/users</code> Exact path <code>/users/*</code> Single segment: <code>/users/123</code>, <code>/users/abc</code> <code>/api/**</code> Any depth: <code>/api/v1</code>, <code>/api/v1/users/123</code> <code>/users/*/profile</code> <code>/users/123/profile</code>, <code>/users/abc/profile</code> <p>Note</p> <p>Query strings are ignored when evaluating path patterns.</p>"},{"location":"policies/#complete-examples","title":"Complete Examples","text":"<pre><code># HTTPS to specific API endpoint\n\"https://api.example.com/v1/exports/**\"\n\n# Any subdomain of partner.com on custom port\n\"https://*.partner.com:8443/payments/**\"\n\n# HTTP to any host, specific path\n\"http://*/health\"\n\n# IPv6 address\n\"https://[2001:db8::1]/api/**\"\n</code></pre>"},{"location":"policies/#payload-inspection","title":"Payload Inspection","text":"<p>The <code>inspect_payload</code> option controls whether ExfilGuard inspects request/response bodies.</p>"},{"location":"policies/#inspect_payload-true-default","title":"inspect_payload = true (default)","text":"<ul> <li>Full HTTP inspection including headers and body</li> <li>TLS is terminated and re-encrypted (MITM)</li> <li>Required for non-CONNECT methods</li> <li>HTTPS rules implicitly authorize CONNECT bumping for the same host/port</li> <li>Enables full request/response inspection for logging, metrics, and caching (when configured)</li> </ul>"},{"location":"policies/#inspect_payload-false-tunnel-mode","title":"inspect_payload = false (tunnel mode)","text":"<ul> <li>Traffic is tunneled without inspection</li> <li>Only valid with <code>methods = [\"CONNECT\"]</code></li> <li>Only valid with URL pattern path <code>/**</code> (e.g., <code>https://secure.partner.com/**</code>)</li> <li>CONNECT tunnel rules must appear before non-CONNECT rules inside each policy</li> <li>Useful for certificate-pinned services that refuse MITM</li> </ul> <p>Warning</p> <p>Tunnel mode bypasses content inspection. Use only when necessary (e.g., payment gateways with certificate pinning).</p>"},{"location":"policies/#response-caching","title":"Response Caching","text":"<p>Rules can enable caching for matched responses when the cache subsystem is configured globally.</p> <pre><code>[[policy.rule]]\naction = \"ALLOW\"\nmethods = [\"GET\"]\nurl_pattern = \"https://cdn.example.com/**\"\n  [policy.rule.cache]\n  force_cache_duration = 3600  # Fallback: cache for 1 hour\n</code></pre> Field Type Description <code>force_cache_duration</code> u64 Fallback cache lifetime in seconds (used only when upstream sends no cache headers)"},{"location":"policies/#how-caching-works","title":"How Caching Works","text":"<p>The cache respects standard HTTP caching headers from upstream:</p> <ul> <li>Cache-Control: <code>s-maxage</code>, <code>max-age</code>, <code>public</code>, <code>private</code>, <code>no-cache</code>, <code>no-store</code></li> <li>Expires: HTTP date for expiration</li> <li>Vary: Responses vary by specified request headers</li> </ul> <p><code>force_cache_duration</code> is a fallback only - it does not override upstream freshness. It applies when the upstream response omits <code>s-maxage</code>, <code>max-age</code>, and <code>Expires</code> (including cases where only <code>public</code> is set).</p> <p>Note</p> <p>Only <code>GET</code> and <code>HEAD</code> responses with status 200, 203, 204, 205, 206, 301, or 302 are cached. See Cache Settings for full details.</p>"},{"location":"policies/#complete-examples_1","title":"Complete Examples","text":""},{"location":"policies/#deny-all-fallback","title":"Deny-All Fallback","text":"<pre><code>[[policy]]\nname = \"fallback-deny\"\n  [[policy.rule]]\n  action = \"DENY\"\n  status = 470\n  reason = \"Policy Blocked\"\n  body = \"Blocked by ExfilGuard\\n\"\n</code></pre>"},{"location":"policies/#allow-specific-api-endpoints","title":"Allow Specific API Endpoints","text":"<pre><code>[[policy]]\nname = \"api-policy\"\n  [[policy.rule]]\n  action = \"ALLOW\"\n  methods = [\"GET\", \"POST\"]\n  url_pattern = \"https://api.trusted.com/v1/exports/**\"\n\n  [[policy.rule]]\n  action = \"ALLOW\"\n  methods = [\"ANY\"]\n  url_pattern = \"https://reports.trusted.com/dashboards/**\"\n</code></pre>"},{"location":"policies/#certificate-pinned-service-tunnel","title":"Certificate-Pinned Service (Tunnel)","text":"<pre><code>[[policy]]\nname = \"pinned-payments\"\n  [[policy.rule]]\n  action = \"ALLOW\"\n  methods = [\"CONNECT\"]\n  url_pattern = \"https://secure.partner.com/**\"\n  inspect_payload = false\n  allow_private_upstream = true\n</code></pre>"},{"location":"policies/#cached-static-content","title":"Cached Static Content","text":"<pre><code>[[policy]]\nname = \"cached-content\"\n  [[policy.rule]]\n  action = \"ALLOW\"\n  methods = [\"GET\"]\n  url_pattern = \"https://cdn.example.com/**\"\n    [policy.rule.cache]\n    force_cache_duration = 3600\n</code></pre>"}]}